# Linux通配符

## 一、常见通配符

| 通配符           | 说明                               | 举例             |
| ---------------- | ---------------------------------- | ---------------- |
| ？               | 代表单个任意字符                   | `ls ?a`          |
| *                | 代表任意个单一字符                 | `ls *.cpp`       |
| `[char set]`     | 匹配给出字符集中的任意单一字符     | `ls a[xyz]b`     |
| `[!char set]`    | 匹配除了给出字符集中的任意单一字符 | `ls a[!xyz]b`    |
| `[c1-c2]`        | 匹配`c1`到`c2`中的任意单一字符     | `ls a[0-9x-z]b`  |
| `{string1, ...}` | 匹配给定字符串集合中任意一个字符串 | `ls a{abx,xyz}b` |

具体例子：

```bash
ls -d [ab]?g*
#这是找以a开头的目录
ls -d [!0-9b-zA-Z]*
#多模匹配的时候，模式串与逗号之间不能有空格！！！
ls {algorithm,case,C}* -d
```

**注意：==Linux下的这些只是通配符，不是正则表达式！！！通配符无法完成正则表达式的所有功能。==**

> `grep`命令中只是进行单模匹配，并且无法支持通配符与正则表达式